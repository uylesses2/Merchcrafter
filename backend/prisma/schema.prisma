generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  password  String
  role      String   @default("USER") // "USER" | "ADMIN"
  credits   Int      @default(0)
  createdAt DateTime @default(now())
  lastLoginAt DateTime?
  
  projects      Project[]
  transactions  CreditTransaction[]
  books         Book[]
  analyses      Analysis[]
  feedback      UserFeedback[]
}

model Project {
  id        Int      @id @default(autoincrement())
  userId    Int
  user      User     @relation(fields: [userId], references: [id])
  
  originalFilename String // Treating as "Project Name"
  description String?
  status    String   // "CREATED", "GENERATING"
  
  orchestratorState String? // JSON blob for things like "trait_block"
  
  createdAt DateTime @default(now())

  generations Generation[]
  books       ProjectBook[]
  analyses    Analysis[]
}

model Generation {
  id        Int      @id @default(autoincrement())
  projectId Int
  project   Project  @relation(fields: [projectId], references: [id])
  
  type      String   // "PREVIEW", "FINAL"
  stylePreset String? // For analytics
  entityId  String?  // Nullable for composite scenes
  prompt    String   @default("") // Full prompt used (Legacy text or summary)
  promptPayload String? // Strict JSON prompt payload (v1.0 schema)
  artStyle  String?
  merchStyle String?
  
  provider  String?  // "openai", "gemini"
  model     String?  // "dall-e-3", "imagen-3.0"

  // Orchestrator Fields
  isAnchorCandidate Boolean @default(false)
  thoughtSignatures String? // JSON array of strings
  refsUsedCount     Int    @default(0)

  imageUrl  String?
  status    String   // "PENDING", "COMPLETED", "FAILED"
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
  
  // Relations
  anchoredCanons EntityCanon[] @relation("AnchorImage")
  sourceSheets   CanonSheet[]
}

model CreditTransaction {
  id        Int      @id @default(autoincrement())
  userId    Int
  user      User     @relation(fields: [userId], references: [id])
  
  amount    Int // Positive for grant/purchase, negative for usage
  type      String // "GRANT", "PURCHASE", "PREVIEW", "FINAL"
  createdAt DateTime @default(now())
}

model Book {
  id               String   @id @default(uuid())
  userId           Int
  user             User     @relation(fields: [userId], references: [id])
  title            String
  originalFilename String
  storagePath      String
  pageCount        Int?
  status           String   // PENDING, PROCESSING, READY, FAILED
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  chunks           BookChunk[]
  queries          RagQueryLog[]
  projects         ProjectBook[]
  analyses         AnalysisBook[]

  characters       Character[]
  scenes           Scene[]
  ingestionJobs    IngestionJob[]
  chapters         Chapter[] // Timeline Support
}

model BookChunk {
  id         String   @id @default(uuid())
  bookId     String
  book       Book     @relation(fields: [bookId], references: [id])
  userId     Int      // Scoped for safety
  chunkIndex Int
  
  // Timeline/Structure Support
  chapterId  String?
  chapter    Chapter? @relation(fields: [chapterId], references: [id])
  sceneId    String?
  scene      Scene?   @relation(fields: [sceneId], references: [id])
  sceneIndex Int?     // Local index in chapter
  globalSceneIndex Int? // Global index in book
  
  startPage  Int?
  endPage    Int?
  startChar  Int?     // Absolute char offset start
  endChar    Int?     // Absolute char offset end
  
  text       String
  embedding  String   // Stored as JSON string of float array
  createdAt  DateTime @default(now())
}

model RagQueryLog {
  id          String   @id @default(uuid())
  userId      Int
  bookId      String
  book        Book     @relation(fields: [bookId], references: [id])
  entityType  String
  entityLabel String
  analysisMode String?  @default("VISUAL_ART") // "VISUAL_ART", "PROFILE", "SCENES", "RELATIONSHIPS", "QUOTES"

  createdAt   DateTime @default(now())
}

model Analysis {
  id          String   @id @default(uuid())
  userId      Int
  user        User     @relation(fields: [userId], references: [id])
  projectId   Int?
  project     Project? @relation(fields: [projectId], references: [id])

  entityType  String
  entityName  String
  mode        String
  rawQuery    String?
  resultJson  String   // Stored as JSON string
  summary     String?
  tags        String   // Stored as JSON string array "[]"

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  books       AnalysisBook[]
}

// Join Table for Many-to-Many Project <-> Book
model ProjectBook {
  projectId Int
  bookId    String
  project   Project @relation(fields: [projectId], references: [id])
  book      Book    @relation(fields: [bookId], references: [id])

  @@id([projectId, bookId])
}

// Join Table for Many-to-Many Analysis <-> Book
model AnalysisBook {
  analysisId String
  bookId     String
  analysis   Analysis @relation(fields: [analysisId], references: [id])
  book       Book     @relation(fields: [bookId], references: [id])

  @@id([analysisId, bookId])
}

model UserFeedback {
  id        String   @id @default(uuid())
  userId    Int
  user      User     @relation(fields: [userId], references: [id])
  category  String   // ENTITY_TYPE, ART_STYLE, MERCH_TYPE, GENERAL
  title     String
  message   String
  status    String   @default("NEW") // NEW, IN_REVIEW, RESOLVED
  adminNote String?
  createdAt DateTime @default(now())
}

// =========================================================
// LAYER C: STRUCTURED SUMMARY TABLES (TIMELINE AWARE)
// =========================================================

model Chapter {
  id             String   @id @default(uuid())
  bookId         String
  book           Book     @relation(fields: [bookId], references: [id])
  
  chapterIndex   Int      // Reading order
  title          String?
  startChar      Int      // Absolute offset
  endChar        Int      // Absolute offset
  
  scenes         Scene[]
  chunks         BookChunk[]
  
  createdAt      DateTime @default(now())
}

model Character {
  id        String   @id @default(uuid())
  bookId    String
  book      Book     @relation(fields: [bookId], references: [id])
  
  name      String
  aliases   String?  // JSON array of strings
  role      String?  // "PROTAGONIST", "ANTAGONIST", "SUPPORTING", etc.
  notes     String?
  
  traits    CharacterTrait[]
  scenes    SceneEntity[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model CharacterTrait {
  id              String    @id @default(uuid())
  characterId     String
  character       Character @relation(fields: [characterId], references: [id])
  
  traitType       String    // "PHYSICAL_APPEARANCE", "PERSONALITY", "BACKGROUND", etc.
  description     String
  sourceFragmentId String?  // ID of the micro-fragment in Qdrant (optional linkage)
  sourcesSummary  String?   // Short verification text
  
  createdAt       DateTime  @default(now())
}

model Scene {
  id              String   @id @default(uuid())
  bookId          String
  book            Book     @relation(fields: [bookId], references: [id])
  
  chapterId       String?
  chapter         Chapter? @relation(fields: [chapterId], references: [id])
  
  sceneIndex      Int      // Index within chapter
  globalSceneIndex Int     // Global index across book for timeline ordering
  
  title           String?
  summary         String
  povCharacter    String?  // Name if known
  location        String?
  
  startChar       Int?     // Absolute offset start
  endChar         Int?     // Absolute offset end
  
  // Structured Data (JSON)
  temporalHints   String?  // JSON: { "relative": ["before X"], "timeOfDay": "morning" }
  mainEvents      String?  // JSON list of strings
  
  entities        SceneEntity[]
  chunks          BookChunk[]
  
  createdAt       DateTime @default(now())
  
  // Ensure global order uniqueness per book if possible, or usually just trust app logic
  // @@unique([bookId, globalSceneIndex]) 
}

model SceneEntity {
  id          String   @id @default(uuid())
  sceneId     String
  scene       Scene    @relation(fields: [sceneId], references: [id])
  characterId String?  // Optional direct link to Character
  character   Character? @relation(fields: [characterId], references: [id])
  
  entityName  String   // Name as it appears in the scene if not linked
  entityType  String?  // "CHARACTER", "LOCATION", "ITEM", "CREATURE"
  role        String?  // "PRIMARY", "BACKGROUND", "MENTIONED"
}

// =========================================================
// LLM CONFIGURATION & USAGE
// =========================================================

model LLMProvider {
  id                String   @id @default(uuid())
  name              String   @unique // "gemini" | "openai"
  encryptedKey      String?  // Provider-level Default Key
  settings          String?  // JSON string for extra config (url, orgId)
  lastKeyTestStatus String   @default("unknown") // "unknown" | "valid" | "invalid"
  lastKeyTestedAt   DateTime?
  
  updatedAt         DateTime @updatedAt
  createdAt         DateTime @default(now())
}

model LLMTaskConfig {
  id           String   @id @default(uuid())
  task         String   @unique // "embeddings" | "microFragmentLabeling" | "analyzer" | "imageGeneration"
  providerName String
  modelName    String
  dailyBudget  Int      @default(200)
  budgetEnabled Boolean @default(true)
  pricePer1kTokens Float @default(0.0)
  
  updatedAt    DateTime @updatedAt
}

model DailyTaskUsage {
  id           String   @id @default(uuid())
  date         String   // YYYY-MM-DD
  task         String
  count        Int      @default(0)
  inputTokens  Int      @default(0)
  outputTokens Int      @default(0)
  estimatedCost Float   @default(0.0)
  
  updatedAt    DateTime @updatedAt
  
  @@unique([date, task])
}

model BookTaskUsage {
  id           String   @id @default(uuid())
  bookId       String
  task         String
  date         String // YYYY-MM-DD (optional, if we want day-by-day breakdown per book)
  
  requests     Int      @default(0)
  inputTokens  Int      @default(0)
  outputTokens Int      @default(0)
  estimatedCost Float   @default(0.0)

  updatedAt    DateTime @updatedAt
  
  // We might want just one record per book/task total? 
  // User asked for "per book" view. 
  // Let's keep date to allow drilled down analytics if needed, or query sum.
  @@unique([bookId, task, date])
}

model LLMModelConfig {
  id                   String   @id @default(uuid())
  providerName         String
  modelName            String
  encryptedKeyOverride String?
  lastKeyTestStatus    String   @default("unknown")
  lastKeyTestedAt      DateTime?
  
  dailyBudget          Int      @default(10000)
  budgetEnabled        Boolean  @default(true)
  
  updatedAt            DateTime @updatedAt

  @@unique([providerName, modelName])
}

model GlobalSettings {
  key   String @id
  value String
}

model DailyModelUsage {
  id           String   @id @default(uuid())
  date         String   // YYYY-MM-DD
  providerName String
  modelName    String
  requests     Int      @default(0)
  inputTokens  Int      @default(0)
  outputTokens Int      @default(0)

  updatedAt    DateTime @updatedAt

  @@unique([date, providerName, modelName])
}


model IngestionJob {
  id        String   @id @default(uuid())
  bookId    String
  book      Book     @relation(fields: [bookId], references: [id])
  status    String   @default("queued") // "queued" | "processing" | "done" | "failed"
  message   String?
  error     String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ORCHESTRATOR MODELS

model EntityCanon {
  id              String   @id @default(uuid())
  entityId        String   // Link to Character.id or others
  entityType      String   // "character", "vehicle", etc.
  
  anchorImageId   Int?
  anchorImage     Generation? @relation("AnchorImage", fields: [anchorImageId], references: [id])
  
  canonVersion    Int      @default(0)
  status          String   @default("NONE") // "NONE", "BUILDING", "SHEETS_GENERATED", "READY"
  
  sheets          CanonSheet[]
  references      EntityReferenceImage[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model CanonSheet {
  id              String   @id @default(uuid())
  canonId         String
  canon           EntityCanon @relation(fields: [canonId], references: [id])
  
  sheetType       String   // "turnaround", "face"
  imageUrl        String
  
  sourceAnchorId  Int?
  sourceAnchor    Generation? @relation(fields: [sourceAnchorId], references: [id])
  
  createdAt       DateTime @default(now())
}

model EntityReferenceImage {
  id              String   @id @default(uuid())
  canonId         String
  canon           EntityCanon @relation(fields: [canonId], references: [id])
  
  url             String
  tag             String   // "identity", "outfit", "face"
  
  sourceSheet     String?  // "turnaround", "face"
  cropName        String?  // "front", "side", "neutral"
  
  createdAt       DateTime @default(now())
}
